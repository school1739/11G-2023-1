import random

glasses = {1: [1] * 5 + [2] * 5,  # Стаканчики с бумажками
           2: [1] * 5 + [2] * 5,
           3: [1] * 5 + [2] * 5,
           4: [1] * 5 + [2] * 5,
           5: [1] * 5 + [2] * 5,
           6: [1] * 5 + [2] * 5,
           7: [1] * 5 + [2] * 5,
           8: [1] * 5 + [2] * 5,
           9: [1] * 5 + [2] * 5,
           10: [1] * 5 + [2] * 5,
           11: [1] * 5 + [2] * 5}


# Функция для изменения содержимого стаканов
def game_lost(num_of_glas):
    num_of_glas_list = list(num_of_glas)
    for i in num_of_glas_list:
        if len(glasses[i]) > 1:  # Убираем листочек
            glasses[i].remove(num_of_glas[i][0])
        elif num_of_glas[i][1] == 10:  # Убираем последний листочек, если кол-во проигрышей на нём равно 10
            glasses[i].remove(num_of_glas[i][0])

wins = 0  # кол-во побед подряд
while wins <= 4:  # игра до пяти побед включительно
    current_glasses = 10
    num_of_glas = {}
    loss = 0  # Кол-во проигрышей. Нужно чтобы знать кол-во проигрышей на таком-то листочке в таком-то стакане
    # print(wins)  # выводит кол-во побед подряд

    while True:
        user_stiks = random.randrange(1, 2)  # Сколько палочек выбирает пользователь
        current_glasses -= user_stiks  # Игрок берёт палочки
        if current_glasses == 1:  # Проверка на проигрыш
            wins = 0
            game_lost(num_of_glas)  # Изменение содержимого стаканов, если сеть проиграла
            break

        # Из задания непонятно, как ходит игрок: случайно или пытается выиграть?
        # Я сделал так, что он ходит случайно
        elif current_glasses <= 0:  # Проверка на выигрыш
            wins += 1
            break

        num_from_glas = random.choice(glasses[current_glasses])
        num_of_glas[current_glasses] = num_from_glas, loss
        current_glasses -= num_from_glas  # Нейросеть берёт палочки

        if current_glasses == 1:  # Проверка на выигрыш
            wins += 1
            break

        elif current_glasses == 0:  # Проверка на проигрыш
            wins = 0
            game_lost(num_of_glas)
            break

for i in range(1, 12):  # Содержимое стаканов
    print(f"В {i} содержится {glasses[i]}.")
    probability_1 = glasses[i].count(1) / len(glasses[i])
    print(f"Вероятность достать 1 из стакана: {probability_1}.")
    print(f"Вероятность достать 2 из стакана: {1 - probability_1}.")
    print()

#  К сожалению, я пока не до конца понял, что это означает и как это сделать: "Если несколько "нейронов" одновремено принимают неверные решения, удаляются не все сразу, а нейрон
# с минимальным номером, через 10 неудач -- следующий минимальный и т.д..".
# Но видимо из-за этого моя программа иногда зацикливается и не выдает правилный ответ.
# Буду искать решение

# ^^^
# Не совсем так. Про 10 проигрышей -- это в том случае, когда в нейроне остаётся одна последняя бумажка.
# Надо стараться не допускать такого, но защита "от дурного ИИ" должна быть.

# Мысли правильные,но совсем уж сырое. Думаю, если бы переписал в виде классов, а внутрь их методов добавил бы
# какие-нибудь принты для вывода всякой дебажной инфы, обеспечив себе понятность процессов, было бы проще разобраться.

# Почти OK